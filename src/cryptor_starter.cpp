//============================================================================================================
// C O P Y R I G H T
//------------------------------------------------------------------------------------------------------------
/// \copyright (C) 2022 Robert Bosch GmbH. All rights reserved.
//============================================================================================================
/// @file

#include "cryptor/cryptor_starter.h"
#include "cryptor/cryptor_encoder.h"
#include "dat_src_arr_null.h"
#include "dat_src_arr_as_readonly_random_access_file.h"
#include "dat_src_arr_as_random_access_file.h"
#include "dat_src_arr_as_readonly_string.h"
#include "dat_src_arr_as_string.h"
#include "static_helper.h"
#include <sstream>
#include <string>
#include <vector>
#include <exception>
#include <memory>
#include <functional>
#include <ctime>
#include <algorithm>
#include <locale>
#include <iostream>

#if __cplusplus >= 201703L // https://stackoverflow.com/a/51536462/7302562 and https://stackoverflow.com/a/60052191/7302562
#include <filesystem>
#endif

using namespace vfm;

void CryptorStarter::decrypt(const std::shared_ptr<DataSrcArray>& in_encrypted_array, const std::shared_ptr<DataSrcArray>& out_decrypted_array)
{
	decryptor->applyRules(in_encrypted_array, out_decrypted_array);
}

void CryptorStarter::encrypt(const std::shared_ptr<DataSrcArray>& in_decrypted_array, const std::shared_ptr<DataSrcArray>& out_encrypted_array)
{
	encryptor->applyRules(in_decrypted_array, out_encrypted_array);
}

std::string CryptorStarter::encrypt_easy(const std::string& word)
{
	return encryptor->process_easy(word);
}

std::string CryptorStarter::decrypt_easy(const std::string& word)
{
	return decryptor->process_easy(word);
}

std::shared_ptr<DataPack> CryptorStarter::get_data() const
{
	return data;
}

void CryptorStarter::autoCreateEncoder()
{
	//if (debug_output >= 0) std::cout << std::endl << "Auto-creating Encryptor from Decryptor...";
	encryptor->autoCreateFromOther(decryptor);
	pars_.enc_file_path = pars_.dec_file_path + ".autogenerated.enc";
	encryptor->storeToFile(pars_.dec_file_path);
	//if (debug_output >= 0) std::cout << "Auto-created Encryptor from Decryptor and stored in '" << pars_.enc_file_path << "'. Please inspect the result.";
}

void CryptorStarter::autoCreateDecoder()
{
	//if (debug_output >= 0) std::cout << std::endl << "Auto-creating Decryptor from Encryptor...";
	decryptor->autoCreateFromOther(encryptor);
	pars_.dec_file_path = pars_.enc_file_path + ".autogenerated.dec";
	decryptor->storeToFile(pars_.dec_file_path);
	//if (debug_output >= 0) std::cout << "Auto-created Decryptor from Encryptor and stored in '" << pars_.dec_file_path << "'. Please inspect the result.";
}

std::shared_ptr<CryptorEncoder> CryptorStarter::getEncryptor()
{
	return encryptor;
}

std::shared_ptr<CryptorEncoder> CryptorStarter::getDecryptor()
{
	return decryptor;
}

// ** TESTING **

bool CryptorStarter::test(const std::string& test_word, const bool& verbose)
{
	std::string enc = encrypt_easy(test_word);
	std::string dec = decrypt_easy(enc);

   if (verbose) {
      addNote("dec('" + test_word + "') = '" + enc + "'.");
      addNote("dec(enc('" + test_word + "')) = '" + dec + "'.");
   }

	return dec == test_word;
}

/*
 * From https://stackoverflow.com/questions/440133/how-do-i-create-a-random-alpha-numeric-string-in-c
 * This function is licensed under CC-BY-SA-4.0 which is a copy-left license
 * (https://creativecommons.org/licenses/by-sa/4.0/deed.en)!
 */
auto randchar_alphanumeric = []() -> char
{
	const char charset[] =
		"0123456789"
		"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		"abcdefghijklmnopqrstuvwxyz";
	const size_t max_index = (sizeof(charset) - 1);
	return charset[rand() % max_index];
};

auto randchar_arbitrary = []() -> char
{
	return rand() % 256;
};

std::string random_string(size_t length, std::function<char(void)> rand_char)
{
	std::string str(length, 0);
	std::generate_n(str.begin(), length, rand_char);
	return str;	
}

void CryptorStarter::testWithOutput(int& failed, const std::string& s, const bool& verbose) {
	std::string o = s.size() < /*50*/ 0 ? s : std::string("string of size ") + std::to_string(s.size());
	std::string res = " FAILED.";
   std::string temp;

	clock_t begin = clock();
	if (test(s, verbose)) res = " OK."; else ++failed;
	clock_t end = clock();

   temp += "Tested '" + o + "'...";
	temp += res + " (" + std::to_string(float(end - begin)) + " ms.)";
   addNote(temp);
}

bool CryptorStarter::testManyRandom(const int & how_many_alpha_numeric, const int & how_many_arbitrary, const int& size_min, const int& size_max)
{
	int failed = 0;

	if (how_many_alpha_numeric) {
		addNote("TESTING " + std::to_string(how_many_alpha_numeric) + " alpha-numeric strings by decoding their encoding.");
		for (int i = 0; i < how_many_alpha_numeric; i++) {
			std::string s = random_string(size_min + (rand() % static_cast<int>(size_max - size_min + 1)), randchar_alphanumeric);
			testWithOutput(failed, s, false);
		}
	}

	if (how_many_arbitrary) {
      addNote("TESTING " + std::to_string(how_many_arbitrary) + " arbitrary strings by decoding their encoding.");

		for (int i = 0; i < how_many_arbitrary; i++) {
			std::string s = random_string(size_min + (rand() % static_cast<int>(size_max - size_min + 1)), randchar_arbitrary);
			testWithOutput(failed, s, false);
		}
	}

	addNote("TESTING zero-length string by decoding its encoding.");
	testWithOutput(failed, "", false);

	addNote(std::to_string(how_many_alpha_numeric + how_many_arbitrary + 1 - failed) + " of " + std::to_string(how_many_alpha_numeric + how_many_arbitrary + 1) + " strings tested successfully.");

	return failed == 0;
}

// ** EO TESTING **

// ** COMMAND LINE ARGS, PRINTING etc. **

std::string internal_var = "__init";
bool contains_plain_eqs_enc = false;
bool contains_plain_eqs_dec = false;
std::stringstream init_line_enc;
std::stringstream init_line_dec;
std::vector<std::string> lines_enc;
std::vector<std::string> lines_dec;

void CryptorStarter::resetCommandLineVars()
{
	contains_plain_eqs_enc = false;
	contains_plain_eqs_dec = false;
	init_line_enc = std::stringstream();
	init_line_dec = std::stringstream();
	lines_enc.clear();
	lines_dec.clear();

	init_line_enc << "[" << internal_var << "==0]";
	init_line_dec << "[" << internal_var << "==0]";
}

void CryptorStarter::applyMode(const CryptingMode& mode) {
   if (mode == CryptingModeEnum::enc && pars_.in_file_pattern == INVALID_VALUE) pars_.in_file_pattern = pars_.DEFAULT_IN_FILE_PATTERN_ENC;
	if (mode == CryptingModeEnum::dec && pars_.in_file_pattern == INVALID_VALUE) pars_.in_file_pattern = pars_.DEFAULT_IN_FILE_PATTERN_DEC;
}

void CryptorStarter::processCommandLineArg(std::string& key, std::string& val) {
	if (key == CPAR_ALG || key == CPAR_ALG + CPAR_ENC) {
		if (val[0] == OPENING_COND_BRACKET) {
			lines_enc.push_back(val);
		}
		else {
			init_line_enc << val << RULE_EQ_SEPARATOR;
			contains_plain_eqs_enc = true;
		}
	}
	if (key == CPAR_ALG || key == CPAR_ALG + CPAR_DEC) {
		if (val[0] == OPENING_COND_BRACKET) {
			lines_dec.push_back(val);
		}
		else {
			init_line_dec << val << RULE_EQ_SEPARATOR;
			contains_plain_eqs_dec = true;
		}
	}
	if (key == CPAR_IN_TYPE) pars_.in_type.setValue(val);
	if (key == CPAR_OUT_TYPE) pars_.out_type.setValue(val);
	if (key == CPAR_MODE) pars_.mode.setValue(val);
	if (key == CPAR_IN_FILE_PATTERN) pars_.in_file_pattern = val;
	if (key == CPAR_AUTO_CREATE_DEC) pars_.auto_create_dec.setValue(val);
	if (key == CPAR_AUTO_CREATE_ENC) pars_.auto_create_enc.setValue(val);
	if (key == CPAR_TEST_MIN_SIZE) pars_.test_min_size = std::stoi(val);
	if (key == CPAR_TEST_MAX_SIZE) pars_.test_max_size = std::stoi(val);
	if (key == CPAR_TEST_NUM) pars_.test_num = std::stoi(val);
	if (key == CPAR_JIT) pars_.jit = val != "0" && val != "false";
	if (key == CPAR_ENC_FILE_PATH) pars_.enc_file_path = val;
	if (key == CPAR_DEC_FILE_PATH) pars_.dec_file_path = val;
	if (key == CPAR_IN_PATH) pars_.in_path = val;
	if (key == CPAR_ENC_FILE_EXTENSION) pars_.enc_file_extension = val;
}

void CryptorStarter::processCommandLineArgs(int argc, char* argv[])
{
	if (argc < 2) return;
	resetCommandLineVars();

	//if (debug_output) std::cout << "These are the command line parameters:" << std::endl;
	for (int i = 1; i < argc; i++) {
      auto pair = StaticHelper::split(argv[i], CPAR_DELIMITER);

      if (pair.size() == 1) {
         pair = { pair[0], "" };
      }

		processCommandLineArg(pair[0], pair[1]);
	}

	addNote(std::string("These are the options I am going to use: ")
		+ "\r\n   " + CPAR_IN_TYPE + " = " + pars_.in_type.getEnumAsString()
		+ "\r\n   " + CPAR_OUT_TYPE + " = " + pars_.out_type.getEnumAsString()
		+ "\r\n   " + CPAR_ENC_FILE_PATH + " = " + pars_.enc_file_path
		+ "\r\n   " + CPAR_DEC_FILE_PATH + " = " + pars_.dec_file_path
		+ "\r\n   " + CPAR_IN_FILE_PATTERN + " (enc extension) = " + pars_.enc_file_extension
		+ "\r\n   " + CPAR_IN_FILE_PATTERN + " (in file pattern) = " + pars_.in_file_pattern
		+ "\r\n   " + CPAR_AUTO_CREATE_ENC + " = " + pars_.auto_create_enc.getEnumAsString()
		+ "\r\n   " + CPAR_AUTO_CREATE_DEC + " = " + pars_.auto_create_dec.getEnumAsString()
		+ "\r\n   " + CPAR_MODE + " = " + pars_.mode.getEnumAsString()
		+ "\r\n   " + CPAR_IN_PATH + " = " + pars_.in_path
		+ "\r\n   " + CPAR_JIT + " = " + std::to_string(pars_.jit)
		+ "\r\n   " + CPAR_TEST_MIN_SIZE + " = " + std::to_string(pars_.test_min_size)
		+ "\r\n   " + CPAR_TEST_MAX_SIZE + " = " + std::to_string(pars_.test_max_size)
		+ "\r\n   " + CPAR_TEST_NUM + " = " + std::to_string(pars_.test_num)
		+ "\r\n   " + CPAR_ENC_FILE_EXTENSION + " = " + pars_.enc_file_extension);

	bool enc_available = pars_.enc_file_path != INVALID_VALUE && encryptor->loadFromFile(pars_.enc_file_path);
	bool dec_available = pars_.dec_file_path != INVALID_VALUE && decryptor->loadFromFile(pars_.dec_file_path);

	if (!enc_available && !dec_available) addNote("Note that neither encryptor nor decryptor have been loaded from file. Did you intend this?");

	if (pars_.auto_create_enc == AutoModeEnum::auto_create_always || (pars_.mode != CryptingModeEnum::dec && pars_.auto_create_enc == AutoModeEnum::auto_create_if_missing && !enc_available)) {
		autoCreateEncoder();
	}

	if (pars_.auto_create_dec == AutoModeEnum::auto_create_always || (pars_.mode != CryptingModeEnum::enc && pars_.auto_create_dec == AutoModeEnum::auto_create_if_missing && !dec_available)) {
		autoCreateDecoder();
	}

	init_line_enc << internal_var << SYMB_EQUATION << internal_var << SYMB_EQ << internal_var << RULE_EQ_SEPARATOR;
	init_line_dec << internal_var << SYMB_EQUATION << internal_var << SYMB_EQ << internal_var << RULE_EQ_SEPARATOR;

	if (contains_plain_eqs_enc) encryptor->addRule(init_line_enc.str());
	if (contains_plain_eqs_dec) decryptor->addRule(init_line_dec.str());

	for (auto s : lines_enc) encryptor->readAlgRule(s);
	for (auto s : lines_dec) decryptor->readAlgRule(s);

   addNote("This is the crypting algorithm:");
   std::cout << std::endl << *this;
}

const std::string ag = " <auto-generated>";

std::ostream& operator<<(std::ostream &os, CryptorStarter const &m) {
	const std::string age = m.encryptor->isAutoGenerated() ? ag : "";
	const std::string agd = m.decryptor->isAutoGenerated() ? ag : "";
	os << "ENCRYPTOR" << age << ":" << std::endl << m.encryptor->toString() << std::endl;
	os << "DECRYPTOR" << agd << ":" << std::endl << m.decryptor->toString() << std::endl;
	return os;
}

// ** EO COMMAND LINE ARGS, PRINTING etc. **

// From https://stackoverflow.com/questions/3300419/file-name-matching-with-wildcard
// This function is licensed under CC-BY-SA-4.0 which is a copy-left license
// (https://creativecommons.org/licenses/by-sa/4.0/deed.en)!
bool match(char const *needle, wchar_t const *haystack) {
	for (; *needle != '\0'; ++needle) {
		switch (*needle) {
		case '?':
			if (*haystack == '\0')
				return false;
			++haystack;
			break;
		case '*': {
			if (needle[1] == '\0')
				return true;
			size_t max = wcslen(haystack);
			for (size_t i = 0; i < max; i++)
				if (match(needle + 1, haystack + i))
					return true;
			return false;
		}
		default:
			if (*haystack != *needle)
				return false;
			++haystack;
		}
	}
	return *haystack == '\0';
}

bool match(const char *needle, const std::string& haystack) {
	return match(needle, (wchar_t const *) nullptr); 
	// This does nothing when compiled with GCC where c_str() yields std::string.
	// TODO: Implement conversion from std::string to wchar_t to make it work on linux.
}

std::string CryptorStarter::helper(const std::string in_name, const int& cnt) {
	std::string out_name = pars_.mode == CryptingModeEnum::enc
		? in_name + pars_.enc_file_extension
		: in_name.substr(0, in_name.size() - pars_.enc_file_extension.length());
	std::shared_ptr<DataSrcArray> nil = std::make_shared<DataSrcArrayNull>();
	std::shared_ptr<DataSrcArray> in = nil;
	std::shared_ptr<DataSrcArray> out = nil;
   std::string res = "";
   const std::string mm = pars_.mode == CryptingModeEnum::enc ? "Encrypted" : "Decrypted";

	if (pars_.in_type == MediumTypeEnum::filerw) {
		in = std::make_shared<DataSrcArrayAsRandomAccessFile>(in_name, false);

		res += mm + " 'file (RW) " + in_name + "'";
	}
	else if (pars_.in_type == MediumTypeEnum::file) {
		in = std::make_shared<DataSrcArrayAsReadonlyRandomAccessFile>(in_name);

		res += mm + " 'file (R) " + in_name + "'";
	}
	else if (pars_.in_type == MediumTypeEnum::screen) {
		std::string input;
		std::cout << "Enter string to process: ";
		std::getline(std::cin, input);
		in = std::make_shared<DataSrcArrayAsReadonlyString>(input);

		res += mm + " 'screen', i.e., user input of size " + std::to_string(input.length());
	}
	else {
		res += mm + " with no explicit input";
	}
	if (pars_.out_type == MediumTypeEnum::filerw) {
		out = std::make_shared<DataSrcArrayAsRandomAccessFile>(out_name, in_name != out_name);

		res += " to 'file (RW) " + out_name + "'.";
	}
	else if (pars_.out_type == MediumTypeEnum::file) {
		out = std::make_shared<DataSrcArrayAsReadonlyRandomAccessFile>(out_name);

		res += " to 'file (R; are you sure you didn't mean to use option '" + CPAR_OUT_TYPE + CPAR_DELIMITER + MediumType(MediumTypeEnum::filerw).getEnumAsString() + "'?) " + out_name + "'.";
	}
	else if (pars_.out_type == MediumTypeEnum::screen) {
		out = std::make_shared<DataSrcArrayAsString>(in->size() + 100);

		res += " to 'screen'.";
	}
	else {
		res += " using no explicit output.";
	}

	if (pars_.mode == CryptingModeEnum::enc) encrypt(in, out); else decrypt(in, out);

	if (pars_.out_type == MediumTypeEnum::screen) {
		res += "\r\nResult: " + out->to_string();
		//if (debug_output) std::cout << "This is the map I used (C is the encrypted, D the decrypted string):" << std::endl << data << std::endl;
	}

   return res;
}

void CryptorStarter::run()
{
	if (pars_.mode == CryptingModeEnum::tester) {
		addNote("*** Test mode ***");
      addNote("");
      addNote(std::string("*** Be aware that tests may fail if the algorithm assumes implicit adoption of string positions which are not altered. ")
         + "For example, the simple.enc algorithm aims at a super-fast file encryption by destroying only certain bytes in a file (without creating a copy of that file). "
         + "It works only if the input string is the same as the ouput string. Otherwise, only the altered position will exist in the output. ***");
      addNote("");

		if (testManyRandom(pars_.test_num, pars_.test_num, pars_.test_min_size, pars_.test_max_size)) {
			addNote("Test OK.");
		}
		else {
			addError("Test FAILED.");
		}

		for (;;) {
			std::string inp;
			std::cout << std::endl << "Test your own string: ";
			std::getline(std::cin, inp);
			test(inp, true);
		}
	}
	else if (pars_.mode == CryptingModeEnum::enc || pars_.mode == CryptingModeEnum::dec) {
#if __cplusplus >= 201703L
		std::filesystem::path p(pars_.in_path);
		const auto pattern = pars_.in_file_pattern.c_str();
		int cnt = 0;

		if (pars_.in_type == MediumTypeEnum::file || pars_.in_type == MediumTypeEnum::filerw) {
			for (auto& file : std::filesystem::directory_iterator(p)) {
            const auto path = file.path().filename();
				const auto ff = path.c_str();

				if (pars_.in_type == MediumTypeEnum::screen || pars_.in_type == MediumTypeEnum::nil || match(pattern, ff)) {
					std::filesystem::path p2 = p;
					p2 /= ff;
					std::string in_name = p2.string();

					addNote(helper(in_name, cnt));

					cnt++;
 				}
			}
		}
		else {
			for (size_t cnt = 0; cnt < 100; ++cnt) {
				std::string in_name = pars_.in_path + "/" + std::string("output_string_") + std::to_string(cnt) + ".txt";
				addNote(helper(in_name, cnt));
			}
		}
#else
		addError("Directory traversal functionality not supported due to old C++ version.");
#endif
	}
}

CryptorStarter::CryptorStarter(int argc, char* argv[]) 
   : Failable("CryptorStarter"),
   encryptor(std::make_shared<CryptorEncoder>(SYMB_ARR_DEC, SYMB_ARR_ENC, data, pars_)),
   decryptor(std::make_shared<CryptorEncoder>(SYMB_ARR_ENC, SYMB_ARR_DEC, data, pars_))
{
	addNote("*** Running CRYPTOR ***");
	processCommandLineArgs(argc, argv);
}
